---
title: "Coding Challenge"
output: html_document
---

# Agent-Based Tournament Coding Challenge (TU Delft - EPA1315 Data Analysis and Visualization)

## Introduction

In the agent-based tournament coding challenged each agent has to face an interated prisoner's dilemma. The prisoners dilemma is extensively studied in multiple scientific areas, such as economics, machine learning and evolutionary biology [1]. The core concept of the game is that each of the two competitors can choose 1 out of 2 options for each round. These options are to either defect or cooperate. Both player simultaneously and independently select an option and depending on both decisions a payoff for each player is determined.



Payoff | Cooperate | Defect
--- | --- | ---
Cooperate| 4/4 | 0/5
Defect | 5/0 | 2/2








## Common Strategies

#### 1. Always Cooperate
Cooperates on every move, as a strategie this can be considered very social but not most benefial for own interest

#### 2. Always Defect
Defects on every move, this is considered a 'hard' strategy'.

#### 3. Tit for Tat
Cooperates on the first move, then simply copies the opponent’s last move. In experimental tournaments this strategy turned out surprisingly successful.

#### 4. Suspicious Tit for Tat
Same as Tit for Tat, except that it defects on the first move.

#### 5. Pavlov
Cooperates on the first move, and defects only if both the players did not agree on the previous move.

#### 6. Spiteful
Cooperates, until the opponent defects, and thereafter always defects. Can work out positively in terms of own interest, but may also be risky if first opponent defect occurs early.

#### 7. Random Player
Makes a random move each turn again.

#### 8. Periodic player CD:
Plays C, D periodically.

#### 9. Periodic player DDC
Plays D, D, C periodically.

#### 10. Periodic player CCD
Plays C, C, D periodically.

#### 11. Tit for Two Tats
Cooperates on the first move, and defects only when the opponent defects two times. Compared to the regular tit for tat, this strategy is more socially oriented.

#### 12. Soft Majority
Begins by cooperating, and cooperates as long as the number of times the opponent has cooperated is greater than or equal to the number of times it has defected. When this is no longer the case it defects.

#### 13, Hard Majority
Defects on the first move, and defects if the number of defections of the opponent is greater than or equal to the number of times it has cooperated, else cooperates.

#### 14. Hard Tit for Tat
Cooperates on the first move, and defects if the opponent has defects on any of the previous three moves, else cooperates.

#### 15. NaiveProber
Like TitforTat,but occasionally, randomly defects.

#### 16. Remorseful Prober :
Like Naive Prober, but it tries to break the series of mutual defections after defecting.

[1]

## Selected Strategie

### Axelrod Single- Objective Evolutionary Algorithm

The concept of our agent is based on the fact that for each move in the game there are four possibilities. Both players can cooperate (CC or R for reward), the first player cooperats and the other player defects (CD or S for sucker), the first player can defect and the second cooperates (DC or T for temptation), or both players defect (DD or P for penalty). For our strategie we consider the last three moves as a three letter code. For instance, the situation is which the last three rounds both agents cooperated, has a three letter sequence RRR.

This combination of letters is used to generate a number 0:63. This is done by setting R=0, T=1, S=2 and P=3 and interpret it as a number on base 4. SSP for instance is 43 is this way. Each of the numbers 0:63 either stands for defect or cooperate, therefore based on the last 3 moves a option is selected. Since this decision is based upon the last the 3 moves, the first three moves cannot be defined by this strategy. For this reason these are defected.

An Exception is made for the so called "lemon agents", these agents are introducing themselves by saying "lemon" and will always cheat. For this reason, in a situation of an opponent that introduces itself by "lemon" the defect option is always selected.

### Creating the 64 bit string

As stated before, based on the three letter sequence, converted to a number 0:63, the decision to either defect or cooperate is made. In order to do so each each number 0:63 has a label " defect" or " cooperate". This so called "string" of number is designed by..

(in some subcatogories)....

Main.R looks as follows
```{R}
### Main File to run things in!
##setwd(Set working directory if not yet specified)
#source('scripts/raw_parser.R', chdir = TRUE)
#source('scripts/extract_statistics.R', chdir = TRUE)

## Run parser to create string
#data_frame = axelrod_encode(raw_parser('data/tournament.csv'))

## Run parsed array through statistics
#axelrod_string = extract_statistics(data_frame)
#View(axelrod_string)
```

Before we go into details about our code we first have to make our own 64 bit string. This is done by running the 'main.R' script. This script calls two different stripts, 'raw_parser.R' en 'extract_statistics.R'. The script 'raw_parser.R' looks at the data from the tournament from last year. The script goes through all the played rounds and looks at the pairs of agents that played. These pairs are than sorted and looked at with help of the payoff matrix. The interaction of the agent is translated into a letter. If both players cooperate is called reward (R) and gives us 3 points. If player one cooperates, but player two defects it is called sucker (S) and there are no points for player one. Temptation (T) is the opposite of sucker and rewards player one with 5 points. If both players defect it's called penalty (P) and both get 1 point.

raw_parser.R looks as follows
```{R}
raw_parser = function(file_name) {

    tourn_raw = read.csv(file_name,sep=",",stringsAsFactors = FALSE)
    num_agents = max(unique(tourn_raw$id1)) # Only works if IDs are sequential!
    outcome_sequences = array(data=NA,dim=c(num_agents,num_agents,40)) # 40 is wasteful. See improvement suggestion below.
    # typeof(outcome_sequences) ## just for testing

    ## To get data about the number of games played between each pair
    # seq_length_list = c()

    for (i_id1 in seq(num_agents)) { # The "attacking" agent
        id1_index = which(tourn_raw$id1 %in% i_id1) # Find where agent #i_id1 plays

        for (i_id2 in seq(num_agents)) { # The "defending" agent
            # Agents cannot play themselves, so skip in this case.
            if (i_id1 == i_id2) { # This could be improved by stripping i_id1 from i_id2's for loop declaration
                next
            }

            id2_index = which(tourn_raw$id2 %in% i_id2) # Find where agent #i_id2 plays

            ## The below can be an improvement, but doesn't quite work yet.
            ## The "list" cannot replace the single element.
            # The number of times i_id1 attacks i_id2 to help pre-allocate list
            match_id = which(id1_index %in% id2_index)
            seq_list_len = length(match_id)
            #outcome_sequences[i_id1,i_id2] = vector("list",seq_list_len) # pre-allocate

            # To get data about the number of games played between each pair
            #seq_length_list = c(seq_length_list,seq_list_len)

            for (i in seq(seq_list_len)){
                outcome_sequences[i_id1,i_id2,i] = axelrod_code(
                    tourn_raw$bid1[ id1_index [ match_id[i] ] ],
                    tourn_raw$bid2[ id1_index [ match_id[i] ] ])
            }
        }
    }
    return(outcome_sequences)
}

axelrod_code = function(bid1, bid2) {
    # Determines the letter code associated with an interaction
    if (is.na(bid1)) {
        next
    }
    else if (bid1 == 'cooperate') {
       if (bid1 == bid2) { # CC -> R -> 3
            return("R")
       } else { # CD -> S -> 2
            return("S")
       }
    }  else if (bid1 == 'defect') {
        if (bid1 == bid2) { # DD -> P -> 0
            return("P")
        } else { # DC -> T -> 1
            return("T")
        }
    } else {
       print("Error in cooperate-defect matching!")
       break
    }
}

axelrod_encode = function(a_code) {
    num_agents = nrow(a_code) # Determine number of agents, n, in 'n x n' matrix input
    code_id = decision = win = c()

    for (i in seq(num_agents)) { # The "attacking" agent
        for (j in seq(num_agents)) { # The "defending" agent
            # Agents cannot play themselves, so skip in this case.
            if (i == j) { # This could be improved by stripping i_id1 from i_id2's for loop declaration
                next
            }

            for (k in seq(length(a_code[i,j,])-3)) {

                if (is.na(a_code[i,j,k+3])) { ## Due to dumb coding above, NA exists in list
                    next
                }

                encoded_seq = (a_code[i,j,k] * 4*4 + a_code[i,j,k+1] * 4 + a_code[i,j,k+2] * 1)
                code_id = c(code_id,encoded_seq)

                if (a_code[i,j,k+3] > 1) { # 0 and 1 are defect; 2 and 3
                    decision = c(decision,'C')
                } else {
                    decision = c(decision,'D')
                }

                if (a_code[i,j,k+3] %% 2) { # Consider R and T (1 and 3) as win
                    win = c(win,TRUE)
                } else {
                    win = c(win,FALSE)
                }
            }
        }
    }
    return(data.frame(code_id,decision,win, stringsAsFactors = FALSE))
}

## For testing
# raw_parser("validate.csv")
```

After every meeting between a pair of agents has been translated into a letter, the code will look at sets of 3 meetings. For 3 meetings there're 64 different combinations. The 3 meetings can be expressed in a number by following the following formula: points round 1 * 4^2 = points round 2 *4^1 + points round 3 * 4^0. This formula will give a number between 0 and 63, as to organize the different meeting possibilities. Next the script will safe if the following meeting, the fourth, was won by agent one or agent two and what was played by either. This information is saved and used in the next script, 'extract_statistics.R'. This code looks at which tactic is to do after every combination. This is done by looking at who played what and what the winning percentage is. A win is reward or temptation, this is because another option would have lessend the points. The script returns a string which is 64 digits long and contains C, for cooperate, or D, for defect. This letter represents what the agent should do when it encounters a combination of three meetings.

extract_statistics.R looks as follows
```{R}
get_per <- function(something, file_name,number) {
    #d <- read.csv(file_name,header=TRUE,sep=",")
    d=file_name
    #count the numbers of times the pair made the same decision
    ccnt=0
    for (i in d$decision[d$code_id == number]) {
        if (i == something) {
            ccnt= ccnt+1
        }
    }
    #print(ccnt)

    #count the number of times the agent wins after the three decision
    Tcnt=0
    for (j in d[(d$code_id==number & d$decision==something), c("win")]) {
        if (j == TRUE) {
            Tcnt= Tcnt+1
        }
    }
    #print(Tcnt)
    p <- Tcnt/ccnt
    return(p)
}

extract_statistics <- function( file_name) {
    #d <- read.csv(file_name,header=TRUE,sep=",")
    d= file_name
    #colnames(d)[1] <- "code_id"
    #colnames(d)[2] <- "decision"
    #colnames(d)[3] <- "win"
    str <- NULL
    for (i in 0:63) {
        per_c <- get_per("C", file_name,i)
        #print("next")
        per_d <- get_per("D", file_name,i)
        #print(per_c)
        #print(per_d)
        if (is.na(per_c) | is.na(per_d)) {
            #str <- paste(str, " ",sep="")
            next
        } else if (max(per_c,per_d)>=0.5) {
            str <- paste(str, "D",sep="")
        } else {
            str <-paste(str, "C",sep="")
        }
    }
    return(str)
}

#for testing
#extract_statistics("test_statistics.csv")

```


[1] S. Mittal and K. Deb, “Optimal Strategies of the Iterated Prisoner’s Dilemma Problem for Multiple Conflicting Objectives,” IEEE Trans. Evol. Comput., vol. 13, no. 3, pp. 554–565, Jun. 2009.

[2] R. Axelrod, “The evolution of strategies in the iterated prisoner’s dilemma,” in Genetic Algorithms and Simulated Annealing, L. Davis, Ed. Los Altos, CA: Morgan Kaufmann, 1987.
